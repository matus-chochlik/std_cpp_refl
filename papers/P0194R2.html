<?xml version="1.0"?>
<!--
Autmatically generated file. Do not modify manually all changes will be lost.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8"/>
	<style>
body {
	color: black;
	background-color: white; 
	font-family: "Book Antiqua", "Times New Roman", "Times", serif;
	padding: 2em;
}

h3,h4,h5,h6 {
	font-size: 100%;
}

table {
	border: 2px solid black;
	border-collapse: collapse;
}

th {
	border: 2px solid black;
}

td {
	border: 1px solid black;
}

th, td {
	padding-left: 0.5em;
	padding-right: 0.5em;
}

table.header {
	border: none;
}

table.references {
	border: none;
}

table.header th,
table.header td {
	border: none;
}

table.references th,
table.references td {
	border: none;
}

table.header th {
	text-align: right;
	padding-right: 1em;
	vertical-align: top;
}

table.references th {
	text-align: right;
	padding-right: 1em;
}

table.references td {
	font-style: oblique;
}

table.references td a {
	color: black;
	text-decoration: none;
}

table.references td a:hover {
	color: black;
	text-decoration: underline;
}

blockquote.std {
	color: black;
	background-color: #F1F1F1;
	border: 1px solid #D1D1D1;
	padding-left: 0.5em;
	padding-right: 0.5em;
}

span.section_name {
	float: right;
	font-weight: bold;
}
pre {
	font-family: "Book Antiqua", "Times New Roman", "Times", serif;
	line-height: 1.1em;
}
pre code {
	font-family: "Hack", "OCR A Extended", "Consolas", "Lucida Console", monospace;
	line-height: 1.1em;
	font-size: small;
	-moz-tab-size: 2;
	-o-tab-size: 16;
	tab-size: 2;
}

pre {
	background-color: #F0F0F0;
}

span.note {
	font-style: italic;
}

object.htmlc {
	width: 100%;
	height: auto;
}

</style>
	<title>P0194R2 — Static reflection</title>
</head>
<body>

<table class="header">
	<tr><th>Document Number:</th><td><b>P0194R2</b>, ISO/IEC JTC1 SC22 WG21</td></tr>
  <tr><th>Date:</th><td>2016-10-13</td></tr>
  <tr><th>Project:</th><td>Programming Language C++</td></tr>
  <tr><th>Audience:</th><td>Reflection(SG7) / EWG</td></tr>
  <tr>
    <th rowspan="3">Authors:</th>
    <td>Matúš Chochlík (<a href="mailto:chochlik@gmail.com">chochlik@gmail.com</a>)</td>
  </tr>
  <tr>
    <td>Axel Naumann (axel@cern.ch)</td>
  </tr>
  <tr>
    <td>David Sankel (camior@gmail.com)</td>
  </tr>
</table>

<h1>Static reflection</h1>


<h2>Table of Contents</h2>
<div id="TOC">
	<ul>
		<li><a href="#introduction">Introduction</a>
		</li>
		<li><a href="#interplay">Interplay with other proposals</a>
		</li>
		<li><a href="#wording">Proposed wording</a>
		</li>
		<li><a href="#revisions">Revision history</a>
		</li>
		<li><a href="#acks">Acknowledgments</a>
		</li>
	</ul>
</div>

<div id="introduction">
<h2>Introduction</h2>

<p>This paper is the sixth revision of the proposal to add support for
compile-time reflection to standard C++. We propose that the compiler shall
generate <em>metaobjects</em> — representations of certain program declarations,
which can be reasoned-about at compile time. These metaobjects can then be
used, through a set of <em>operations</em> to obtain various pieces of metadata,
like declaration names, lists of scope members, information about specifiers,
and so on. The <em>metaobjects</em> are implemented as anonymous types
conforming to defined concepts, and the operations are implemented as class
templates.
</p>

<p>This paper is accompanied by another paper — P0385, which discusses the
use cases, rationale, design decisions, future evolution of the proposed reflection
facility and contains multiple examples of use and replies to frequently asked
questions.
</p>
</div>

<div id="interplay">
<h2>Interplay with other proposals</h2>

<p>This proposal relies on the Concepts TS, including a resolution to its
<a href="http://cplusplus.github.io/concepts-ts/ts-active.html#29">Issue 29</a>.
It also assumes that WG21 will incoporate proper compile-time
strings; until then, this proposal provides a placeholder implementation (see
[refl.ops.str]) to facilitate reasoning about the interfaces.
</p>
</div>

<h2 id="wording">Proposed wording</h2>

<p>Insert a new element in Table 1, <em>C++ library headers</em> of
[general.namespaces], named <code>&lt;experimental/reflexpr&gt;</code>.
</p>

<p>Insert a new section:
</p>

<blockquote class="std">
	<h3>? Compile-time reflection <span class="section_name">[refl]</span></h3>

	<h4>?.1 General description <span class="section_name">[refl.general]</span></h4>

	<p>Compile-time constant metadata describing various aspects of a compiled program
	are provided indirectly by the means of types generated by the compiler —
	<em>Metaobjects</em>.

	A <em>Metaobject</em> is an anonymous type <em>reflecting</em>
	(representing) a particular declaration or another base-level entity
	in a C++ program. It can be reasoned-about at compile-time and provides access
	to <em>metadata</em> describing various properties of the reflected entity
	through a set of templates.

	The <em>Metaobject</em> types themselves are opaque, without any visible
	internal structure. Values of such a <em>Metaobject</em> type can be
	default-constructed, copy-constructed and copy-assigned.
	</p>

	<p><em>Metaobject</em>s are generated on demand by the compiler as
	the result of the invocation of the <code>reflexpr</code> operator.
	</p>
	
	<p>The actual metadata is obtained by instantiating templates constituting
	the <em>interface</em> of the <em>Metaobject</em>s. Each template serves a particular
	purpose and provides a single piece of metadata. These templates are
	collectively referred to as <em>Metaobject operations</em>.
	</p>

	<p><em>Metaobject</em>s reflecting different kinds of declarations conform to different
	<em>Metaobject concepts</em> and have different interfaces — sets of templates
	applicable to the <em>Metaobject</em>s. These concepts can also be used for
	<em>Metaobject</em> classification.

	</p><p><em>Metaobject</em> concepts form a generalization-specialization hierarchy, with
	<code>meta::Object</code> being the common generalization for all <em>Metaobject</em>s.
	</p>

	<h4>?.2 <em>Metaobject</em> trait<span class="section_name">[refl.trait]</span></h4>

	<p>A new <em>UnaryTypeTrait</em> — <code>is_metaobject</code> is added
	to section [meta.unary.cat] to distinguish between <em>Metaobject</em> types generated
	by the compiler and all other types.
	</p>

<pre><code>
namespace std {
namespace experimental {

template &lt;typename T&gt; struct is_metaobject;
template &lt;typename T&gt; constexpr bool is_metaobject_v = is_metaobject&lt;T&gt;::value;

} // namespace experimental
} // namespace std
</code></pre>

<pre>
[<span class="note">Example:</span>
<code>
is_metaobject_v&lt;int&gt;;                 // false
is_metaobject_v&lt;reflexpr(int)&gt;;       // true
is_metaobject_v&lt;reflexpr(std)&gt;;       // true
using Mstring = reflexpr(string);
is_metaobject_v&lt;Mstring&gt;;             // true
</code>
<span class="note">— end example</span>]
</pre>

	<h4>?.3 Header <code>&lt;experimental/reflexpr&gt;</code> synopsis<span class="section_name">[refl.synopsis]</span></h4>

	<pre><code>
namespace std {
namespace experimental
namespace meta {

// <em>metaobject concepts</em>
template &lt;typename T&gt; concept bool Object;
template &lt;Object T&gt; concept bool ObjectSequence;
template &lt;Object T&gt; concept bool Reversible;
template &lt;Object T&gt; concept bool Named;
template &lt;Object T&gt; concept bool Alias;
template &lt;Object T&gt; concept bool Typed;
template &lt;Object T&gt; concept bool Scope;
template &lt;Object T&gt; concept bool ScopeMember;
template &lt;Object T&gt; concept bool RecordMember;
template &lt;Object T&gt; concept bool EnumMember;
template &lt;Object T&gt; concept bool Namespace;
template &lt;Object T&gt; concept bool GlobalScope;
template &lt;Object T&gt; concept bool Type;
template &lt;Object T&gt; concept bool TagType;
template &lt;Object T&gt; concept bool Record;
template &lt;Object T&gt; concept bool Class;
template &lt;Object T&gt; concept bool Enum;
template &lt;Object T&gt; concept bool Constant;
template &lt;Object T&gt; concept bool Variable;
template &lt;Object T&gt; concept bool Specifier;
template &lt;Object T&gt; concept bool Inheritance;


// <em>metaobject operations</em>
template &lt;Object T1, Object T2&gt; struct reflects_same;
template &lt;Object T&gt; struct get_source_location;
template &lt;ObjectSequence T&gt; struct get_size;
template &lt;ObjectSequence T1, size_t Index&gt; struct get_element;
template &lt;ObjectSequence T1, template &lt;class...&gt; class Tpl&gt; struct unpack_sequence;
template &lt;Named T&gt; struct is_anonymous;
template &lt;Named T&gt; struct get_base_name;
template &lt;Named T&gt; struct get_display_name;
template &lt;Alias T&gt; struct get_aliased;
template &lt;Typed T&gt; struct get_type;
template &lt;ScopeMember T&gt; struct get_scope;
template &lt;RecordMember T&gt; struct is_public;
template &lt;RecordMember T&gt; struct is_protected;
template &lt;RecordMember T&gt; struct is_private;
template &lt;RecordMember T&gt; struct get_access_specifier;
template &lt;Type T&gt; struct get_reflected_type;
template &lt;TagType T&gt; struct get_elaborated_type_specifier;
template &lt;TagType T&gt; struct is_enum;
template &lt;TagType T&gt; struct is_class;
template &lt;TagType T&gt; struct is_struct;
template &lt;TagType T&gt; struct is_union;
template &lt;Record T&gt; struct get_data_members;
template &lt;Record T&gt; struct get_public_data_members;
template &lt;Record T&gt; struct get_member_types;
template &lt;Record T&gt; struct get_public_member_types;
template &lt;Class T&gt; struct get_base_classes;
template &lt;Class T&gt; struct get_public_base_classes;
template &lt;Enum T&gt; struct is_scoped_enum;
template &lt;Enum T&gt; struct get_enumerators;
template &lt;Constant T&gt; struct get_constant;
template &lt;Variable T&gt; struct is_static;
template &lt;Variable T&gt; struct get_pointer;
template &lt;Inheritance T&gt; struct get_base_class;
template &lt;Inheritance T&gt; struct is_virtual;
template &lt;Inheritance T&gt; struct is_public;
template &lt;Inheritance T&gt; struct is_protected;
template &lt;Inheritance T&gt; struct is_private;
template &lt;Inheritance T&gt; struct get_access_specifier;


// 
template &lt;Object T1, Object T2&gt;
  constexpr auto reflects_same_v = reflects_same&lt;T1, T2&gt;::value;
template &lt;ObjectSequence T&gt;
  constexpr auto get_size_v = get_size&lt;T&gt;::value;
template &lt;ObjectSequence T1, size_t Index&gt;
  using get_element_m = typename get_element&lt;T1, Index&gt;::type;
template &lt;ObjectSequence T1, template &lt;class...&gt; class Tpl&gt;
  constexpr auto unpack_sequence_v = unpack_sequence&lt;T1, Tpl&gt;::value;
template &lt;Named T&gt;
  constexpr auto is_anonymous_v = is_anonymous&lt;T&gt;::value;
template &lt;Named T&gt;
  constexpr auto get_base_name_v = get_base_name&lt;T&gt;::value;
template &lt;Named T&gt;
  constexpr auto get_display_name_v = get_display_name&lt;T&gt;::value;
template &lt;Alias T&gt;
  using get_aliased_m = typename get_aliased&lt;T&gt;::type;
template &lt;Typed T&gt;
  using get_type_m = typename get_type&lt;T&gt;::type;
template &lt;ScopeMember T&gt;
  using get_scope_m = typename get_scope&lt;T&gt;::type;
template &lt;RecordMember T&gt;
  constexpr auto is_public_v = is_public&lt;T&gt;::value;
template &lt;RecordMember T&gt;
  constexpr auto is_protected_v = is_protected&lt;T&gt;::value;
template &lt;RecordMember T&gt;
  constexpr auto is_private_v = is_private&lt;T&gt;::value;
template &lt;RecordMember T&gt;
  using get_access_specifier_m = typename get_access_specifier&lt;T&gt;::type;
template &lt;Type T&gt;
  using get_reflected_type_t = typename get_reflected_type&lt;T&gt;::type;
template &lt;TagType T&gt;
  using get_elaborated_type_specifier_m = typename get_elaborated_type_specifier&lt;T&gt;::type;
template &lt;TagType T&gt;
  constexpr auto is_enum_v = is_enum&lt;T&gt;::value;
template &lt;TagType T&gt;
  constexpr auto is_class_v = is_class&lt;T&gt;::value;
template &lt;TagType T&gt;
  constexpr auto is_struct_v = is_struct&lt;T&gt;::value;
template &lt;TagType T&gt;
  constexpr auto is_union_v = is_union&lt;T&gt;::value;
template &lt;Record T&gt;
  using get_data_members_m = typename get_data_members&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_public_data_members_m = typename get_public_data_members&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_member_types_m = typename get_member_types&lt;T&gt;::type;
template &lt;Record T&gt;
  using get_public_member_types_m = typename get_public_member_types&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_base_classes_m = typename get_base_classes&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_public_base_classes_m = typename get_public_base_classes&lt;T&gt;::type;
template &lt;Enum T&gt;
  constexpr auto is_scoped_enum_v = is_scoped_enum&lt;T&gt;::value;
template &lt;Enum T&gt;
  using get_enumerators_m = typename get_enumerators&lt;T&gt;::type;
template &lt;Constant T&gt;
  constexpr auto get_constant_v = get_constant&lt;T&gt;::value;
template &lt;Variable T&gt;
  constexpr auto is_static_v = is_static&lt;T&gt;::value;
template &lt;Variable T&gt;
  const auto get_pointer_v = get_pointer&lt;T&gt;::value;
template &lt;Inheritance T&gt;
  using get_base_class_m = typename get_base_class&lt;T&gt;::type;
template &lt;Inheritance T&gt;
  constexpr auto is_virtual_v = is_virtual&lt;T&gt;::value;
template &lt;Inheritance T&gt;
  constexpr auto is_public_v = is_public&lt;T&gt;::value;
template &lt;Inheritance T&gt;
  constexpr auto is_protected_v = is_protected&lt;T&gt;::value;
template &lt;Inheritance T&gt;
  constexpr auto is_private_v = is_private&lt;T&gt;::value;
template &lt;Inheritance T&gt;
  using get_access_specifier_m = typename get_access_specifier&lt;T&gt;::type;


} // namespace meta
} // namespace experimental
} // namespace std
</code></pre>


	<h4>?.4 <em>Metaobject</em> concepts<span class="section_name">[refl.concepts]</span></h4>

	<div><table>
<tr>
<th>Concept</th>
<th>Requirements</th>
<th>Description</th>
</tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Object;
</code></pre></td><td><code>is_metaobject_v&lt;T&gt;</code><br/></td><td><p><code>meta::Object</code> is a concept modelled by stateless anonymous types generated by the compiler which allow access to metadata reflecting specific program declarations.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool ObjectSequence;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td><p><code>meta::ObjectSequence</code> is an ordered sequence of metaobjects.</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Reversible;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td><p><code>meta::Reversible</code> is a metaobject that can be reverted to the original   declaration.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Named;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td><p><code>meta::Named</code> reflects a named declaration.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Alias;
</code></pre></td><td><code>Named&lt;T&gt;</code><br/></td><td><p><code>meta::Alias</code> reflects a type or namespace alias.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Typed;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td><p><code>meta::Typed</code> reflects a base-level declaration with a type (for example   a variable).
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Scope;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td><p><code>meta::Scope</code> reflects a scope.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool ScopeMember;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td><p><code>meta::ScopeMember</code> reflects a declaration nested in a scope (like the global scope,   namespace, class, enum, etc.).
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool RecordMember;
</code></pre></td><td><code>ScopeMember&lt;T&gt;</code><br/></td><td><p><code>meta::RecordMember</code> reflects a class, struct or union member.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool EnumMember;
</code></pre></td><td><code>ScopeMember&lt;T&gt;</code><br/></td><td><p><code>meta::EnumMember</code> reflects a enum member.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Namespace;
</code></pre></td><td><code>Named&lt;T&gt;</code><br/><code>Scope&lt;T&gt;</code><br/><code>ScopeMember&lt;T&gt;</code><br/></td><td><p><code>meta::Namespace</code> reflects a namespace.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool GlobalScope;
</code></pre></td><td><code>Namespace&lt;T&gt;</code><br/></td><td><p><code>meta::GlobalScope</code> reflects the global scope.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Type;
</code></pre></td><td><code>Reversible&lt;T&gt;</code><br/><code>Named&lt;T&gt;</code><br/></td><td><p><code>meta::Type</code> reflects a type.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool TagType;
</code></pre></td><td><code>Type&lt;T&gt;</code><br/><code>Scope&lt;T&gt;</code><br/><code>ScopeMember&lt;T&gt;</code><br/></td><td><p><code>meta::TagType</code> reflects a class or an enum.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Record;
</code></pre></td><td><code>TagType&lt;T&gt;</code><br/></td><td><p><code>meta::Record</code> reflects a class, a scope or a union.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Class;
</code></pre></td><td><code>Record&lt;T&gt;</code><br/></td><td><p><code>meta::Class</code> reflects a class or a struct.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Enum;
</code></pre></td><td><code>TagType&lt;T&gt;</code><br/></td><td><p><code>meta::Enum</code> reflects an enumeration.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Constant;
</code></pre></td><td><code>Reversible&lt;T&gt;</code><br/><code>Typed&lt;T&gt;</code><br/></td><td><p><code>meta::Constant</code> reflects a compile-time constant value.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Variable;
</code></pre></td><td><code>Reversible&lt;T&gt;</code><br/><code>Named&lt;T&gt;</code><br/><code>Typed&lt;T&gt;</code><br/><code>ScopeMember&lt;T&gt;</code><br/></td><td><p><code>meta::Variable</code> reflects a variable.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Specifier;
</code></pre></td><td><code>Named&lt;T&gt;</code><br/></td><td><p><code>meta::Specifier</code> reflects a specifier (const, virtual, static, noexcept, public,   protected, private, etc.).
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Inheritance;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td><p><code>meta::Inheritance</code> reflects class inheritance.
		</p></td></tr>
</table></div>

	<p>[<span class="note">Note:</span> <em>Metaobject</em>s reflecting anonymous
	types, anonymous namespaces and the global scope also satisfy the
	<code>meta::Named</code> concept.
	The fact that they reflect an anonymous declaration is indicated by the
	<code>meta::is_anonymous</code> operation. In such case the
	<code>meta::get_base_name</code> and the <code>meta::get_display_name</code>
	operations return an empty (null terminated) string.
	<span class="note">— end note</span>]
	</p>

<pre>
[<span class="note">Example:</span>
<code>
static_assert(meta::Named&lt;reflexpr(string)&gt;, "");
auto l = [](void) { };

static_assert(meta::Named&lt;reflexpr()&gt;, "");
static_assert(meta::Named&lt;reflexpr(decltype(l))&gt;, "");

static_assert(!meta::is_anonymous_v&lt;reflexpr(int)&gt;, "");
auto l = [](void) { };
static_assert(meta::is_anonymous_v&lt;reflexpr(::)&gt;, "");
static_assert(meta::is_anonymous_v&lt;reflexpr(decltype(l))&gt;, "");

static_assert(meta::get_base_name_v&lt;reflexpr(int)&gt;[0] != '\0', "");
auto l = [](void) { };
static_assert(meta::get_base_name_v&lt;reflexpr(::)&gt;[0] == '\0', "");
static_assert(meta::get_base_name_v&lt;reflexpr(decltype(l))&gt;[0] == '\0', "");
</code>
<span class="note">— end example</span>]
</pre>

  <p><em>Metaobject</em>s reflecting fundamental
  types (except for <code>std::nullptr_t</code>),
  pointers (including pointers-to-members), references, arrays and function types
	do not conform to the <em>meta::ScopeMember</em> concept, all other
	types do.
	</p>

<pre>
[<span class="note">Example:</span>
<code>

struct S { };

namespace foo { class C { }; }

static_assert(!meta::ScopeMember(reflexpr(int)), "");
static_assert(!meta::ScopeMember(reflexpr(int*)), "");
static_assert(!meta::ScopeMember(reflexpr(S[10])), "");
static_assert(!meta::ScopeMember(reflexpr(foo::C&amp;)), "");
static_assert(!meta::ScopeMember(reflexpr(int(*)(char, bool))), "");

static_assert( meta::ScopeMember(reflexpr(S)), "");
static_assert( meta::ScopeMember(reflexpr(foo::C)), "");
static_assert( meta::ScopeMember(reflexpr(std::size_t)), "");

</code>
<span class="note">— end example</span>]
</pre>

	<h4>?.5 <em>Metaobject</em> operations<span class="section_name">[refl.ops]</span></h4>

	A <em>MetaobjectOperation</em> extracts
	information from <em>Metaobject</em>s.
	It is a class template taking one or more arguments, at least one
	of which models the <em>Metaobject</em> concept.
	The result of a <em>MetaobjectOperation</em> can be either a compile-time
	constant value, a <code>const</code> pointer, or a type.

	<h5>?.5.1 Boolean constant result<span class="section_name">[refl.ops.bool]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning a boolean value
	derive publicly and unambiguously from <code>true_type</code> or
	<code>false_type</code>.
	</p>

<pre>
[<span class="note">Example:</span>
<code>
struct <em>MetaobjectOperation</em>
 : integral_constant&lt;bool, <em>implementation-defined</em>&gt;
{ };
</code>
<span class="note">— end example</span>]
</pre>

	<h5>?.5.2 Integral or <code>enum</code> constant result<span class="section_name">[refl.ops.int]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning an integer or
	<code>enum</code> value derive publicly and unambiguously from
	a specialization of <code>integral_constant</code>. The first argument's
	integer or <code>enum</code> type is part of the specification of the operation.
	</p>

<pre>
[<span class="note">Example:</span>
<code>
struct <em>MetaobjectOperation</em>
 : integral_constant&lt;<em>integral-or-enum-type</em>, <em>implementation-defined</em>&gt;
{ };
</code>
<span class="note">— end example</span>]
</pre>

	<h5>?.5.3 Pointer result<span class="section_name">[refl.ops.ptr]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates returning a pointer or
	a class data member pointer derive publicly and unambiguously from
	a specialization of <code>integral_constant</code> with value as if taken by the 
  <code>&amp;</code> operator.
	The first argument's pointer or class data member pointer type
	is part of the specification of the operation. 
	</p>

<pre>
[<span class="note">Example:</span>
<code>
struct <em>MetaobjectOperation</em>
 : integral_constant&lt;<em>pointer-or-data-member-pointer-type</em>, <em>implementation-defined</em>&gt;
{ };
</code>
<span class="note">— end example</span>]
</pre>

	<h5>?.5.4 String constant result<span class="section_name">[refl.ops.str]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning a character string
	instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct <em>MetaobjectOperation</em>
{
	typedef const char value_type[N+1];
	static constexpr value_type value = <em>implementation-defined</em>;
};
</code></pre>

	<p>where <code>N</code> is the length of the returned string and the
	last element in the <code>value</code> character array is the
	<code>'\0'</code> character.
	The member names <code>value_type</code> and <code>value</code> are publicly and unambiguously available
	in such <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.5 Type result<span class="section_name">[refl.ops.type]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates yielding a non-<em>Metaobject</em>
	type instantiates into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct <em>MetaobjectOperation</em>
{
	using type = <em>unspecified</em>;
};
</code></pre>

	<p>The <em>MetaobjectOperation</em> templates yielding another <em>Metaobject</em>
	type instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct <em>MetaobjectOperation</em>
{
	using type = <em>Object</em>;
};
</code></pre>

	<p>The member name <code>type</code> is publicly and unambiguously
	available in such <em>MetaobjectOperation</em>.
	</p>


	<h5>?.5.6 Source location result<span class="section_name">[refl.ops.srcloc]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates yielding <code>source_location</code>
	compile-time values will be equivalent to the following:
	</p>

<pre><code>
struct <em>MetaobjectOperation</em>
 : source_location /* <em>initialized in an implementation-defined way</em> */
{ };
</code></pre>

	<h5>?.5.7 Operation description<span class="section_name">[refl.ops.desc]</span></h5>

	<div><table><tr><th>Template</th>
<th>Description</th>
<th>Result</th></tr>
<tr><td><pre><code>template &lt;Object T1, Object T2&gt;
struct reflects_same;
</code></pre></td><td>indicates whether two metaobjects reflect the same base-level   declaration ('entity').</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Object T&gt;
struct get_source_location;
</code></pre></td><td>returns the source location info of the declaration   of a base-level program declaration reflected by a <code>meta::<em>Object</em></code>.</td><td>
		a <code>std::source_location</code> constant
	</td></tr><tr><td><pre><code>template &lt;ObjectSequence T&gt;
struct get_size;
</code></pre></td><td>returns the number of elements in the sequence.</td><td>
		a <code>size_t</code> integral constant
	</td></tr><tr><td><pre><code>template &lt;ObjectSequence T1, size_t Index&gt;
struct get_element;
</code></pre></td><td>returns the i-th <code>meta::<em>Object</em></code> in a <code>meta::<em>ObjectSequence</em></code>.</td><td>
		<code>meta::<em>Object</em></code>
		</td></tr><tr><td><pre><code>template &lt;ObjectSequence T1, template &lt;class...&gt; class Tpl&gt;
struct unpack_sequence;
</code></pre></td><td>unpacks the <code>meta::<em>ObjectSequence</em></code> into a template.</td><td>a type</td></tr><tr><td><pre><code>template &lt;Named T&gt;
struct is_anonymous;
</code></pre></td><td>indicates whether the a named declaration reflected by a <code>meta::<em>Named</em></code>   is anonymous.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Named T&gt;
struct get_base_name;
</code></pre></td><td>returns the basic name of the a named declaration reflected by   a <code>meta::<em>Named</em></code>.</td><td>a string constant</td></tr><tr><td><pre><code>template &lt;Named T&gt;
struct get_display_name;
</code></pre></td><td>returns the display name of the a named declaration reflected by   a <code>meta::<em>Named</em></code>.</td><td>a string constant</td></tr><tr><td><pre><code>template &lt;Alias T&gt;
struct get_aliased;
</code></pre></td><td>returns the <code>meta::<em>Named</em></code> reflecting the original declaration   of a type or namespace alias reflected by a <code>meta::<em>Alias</em></code>.</td><td>
		<code>meta::<em>Named</em></code>
		</td></tr><tr><td><pre><code>template &lt;Typed T&gt;
struct get_type;
</code></pre></td><td>returns the <code>meta::<em>Type</em></code> reflecting the type of a base-level declaration with a type (for example   a variable)   reflected by a <code>meta::<em>Typed</em></code>.</td><td>
		<code>meta::<em>Type</em></code>
		</td></tr><tr><td><pre><code>template &lt;ScopeMember T&gt;
struct get_scope;
</code></pre></td><td>returns the <code>meta::<em>Scope</em></code> reflecting the scope of a declaration nested in a scope (like the global scope,   namespace, class, enum, etc.)   reflected by a <code>meta::<em>ScopeMember</em></code>.</td><td>
		<code>meta::<em>Scope</em></code>
		</td></tr><tr><td><pre><code>template &lt;RecordMember T&gt;
struct is_public;
</code></pre></td><td>indicates whether the a class, struct or union member reflected by a <code>meta::<em>RecordMember</em></code>   was declared with public access.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;RecordMember T&gt;
struct is_protected;
</code></pre></td><td>indicates whether the a class, struct or union member reflected by a <code>meta::<em>RecordMember</em></code>   was declared with protected access.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;RecordMember T&gt;
struct is_private;
</code></pre></td><td>indicates whetherthe a class, struct or union member reflected by a <code>meta::<em>RecordMember</em></code>   was declared with private access.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;RecordMember T&gt;
struct get_access_specifier;
</code></pre></td><td>returns the <code>meta::<em>Specifier</em></code> reflecting the access specifier   of a class, struct or union member reflected by a <code>meta::<em>RecordMember</em></code>.</td><td>
		<code>meta::<em>Specifier</em></code>
		</td></tr><tr><td><pre><code>template &lt;Type T&gt;
struct get_reflected_type;
</code></pre></td><td>returns the the base-level type reflected by a <code>meta::<em>Type</em></code>.</td><td>the original type reflected by the argument</td></tr><tr><td><pre><code>template &lt;TagType T&gt;
struct get_elaborated_type_specifier;
</code></pre></td><td>returns a <code>meta::<em>Specifier</em></code> reflecting the elaborated type specifier   (class,struct,union,...) of a class or an enum reflected by a <code>meta::<em>TagType</em></code>.</td><td>
		<code>meta::<em>Specifier</em></code>
		</td></tr><tr><td><pre><code>template &lt;TagType T&gt;
struct is_enum;
</code></pre></td><td>indicates whether the a class or an enum reflected by a <code>meta::<em>TagType</em></code>   is an enum.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;TagType T&gt;
struct is_class;
</code></pre></td><td>indicates whether the a class or an enum reflected by a <code>meta::<em>TagType</em></code>   is a class.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;TagType T&gt;
struct is_struct;
</code></pre></td><td>indicates whether the a class or an enum reflected by a <code>meta::<em>TagType</em></code>   is a struct.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;TagType T&gt;
struct is_union;
</code></pre></td><td>indicates whether the a class or an enum reflected by a <code>meta::<em>TagType</em></code>   is a union.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Record T&gt;
struct get_data_members;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of <code>meta::<em>Variable</em></code>(s) reflecting all (including   private and protected) data members of a class, a scope or a union reflected by a <code>meta::<em>Record</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
		of <code>meta::<em>Variable</em></code>(s)</td></tr><tr><td><pre><code>template &lt;Record T&gt;
struct get_public_data_members;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of <code>meta::<em>Variable</em></code>(s) reflecting   the public data members of a class, a scope or a union reflected by a <code>meta::<em>Record</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
		of <code>meta::<em>Variable</em></code>(s)</td></tr><tr><td><pre><code>template &lt;Record T&gt;
struct get_member_types;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of <code>meta::<em>Type</em></code>(s) reflecting all (including   private and protected) member types of a class, a scope or a union reflected by a <code>meta::<em>Record</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
		of <code>meta::<em>Type</em></code>(s)</td></tr><tr><td><pre><code>template &lt;Record T&gt;
struct get_public_member_types;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of <code>meta::<em>Type</em></code>(s) reflecting   the public member types of a class, a scope or a union reflected by a <code>meta::<em>Record</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
		of <code>meta::<em>Type</em></code>(s)</td></tr><tr><td><pre><code>template &lt;Class T&gt;
struct get_base_classes;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of <code>meta::<em>Inheritance</em></code>(s) reflecting the inheritance   of all base clases (including the private and protected ones)   of a a class or a struct reflected by a <code>meta::<em>Class</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
		of <code>meta::<em>Inheritance</em></code>(s)</td></tr><tr><td><pre><code>template &lt;Class T&gt;
struct get_public_base_classes;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of <code>meta::<em>Inheritance</em></code>(s) reflecting the inheritance   of public base clases of a a class or a struct reflected by a <code>meta::<em>Class</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
		of <code>meta::<em>Inheritance</em></code>(s)</td></tr><tr><td><pre><code>template &lt;Enum T&gt;
struct is_scoped_enum;
</code></pre></td><td>returns true if the an enumeration reflected by a <code>meta::<em>Enum</em></code>   is scoped.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Enum T&gt;
struct get_enumerators;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of <code>meta::<em>Constant</em></code>(s) reflecting all   enumerators of an enumeration reflected by a <code>meta::<em>Enum</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
		of <code>meta::<em>Constant</em></code>(s)</td></tr><tr><td><pre><code>template &lt;Constant T&gt;
struct get_constant;
</code></pre></td><td>returns the value of a compile-time constant value reflected by a <code>meta::<em>Constant</em></code>.</td><td>
		a constant value of an unspecified, integer or enum type
	</td></tr><tr><td><pre><code>template &lt;Variable T&gt;
struct is_static;
</code></pre></td><td>returns whether the a variable reflected by a <code>meta::<em>Variable</em></code>   was declared with the static specifier.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Variable T&gt;
struct get_pointer;
</code></pre></td><td>returns a pointer to the a variable reflected by a <code>meta::<em>Variable</em></code>.   If the variable is a class member then the pointer is a class data member pointer,   otherwise it is a plain pointer.</td><td>a regular or class data member pointer</td></tr><tr><td><pre><code>template &lt;Inheritance T&gt;
struct get_base_class;
</code></pre></td><td>returns the <code>meta::<em>Inheritance</em></code> reflecting the base class inheritance   in a inheritance.</td><td>
		<code>meta::<em>Class</em></code>
		</td></tr><tr><td><pre><code>template &lt;Inheritance T&gt;
struct is_virtual;
</code></pre></td><td>returns whether the class inheritance reflected by a <code>meta::<em>Inheritance</em></code>   was declared as virtual.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Inheritance T&gt;
struct is_public;
</code></pre></td><td>indicates whether the class inheritance reflected by a <code>meta::<em>Inheritance</em></code>   was declared as public.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Inheritance T&gt;
struct is_protected;
</code></pre></td><td>indicates whether the class inheritance reflected by a <code>meta::<em>Inheritance</em></code>   was declared as protected.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Inheritance T&gt;
struct is_private;
</code></pre></td><td>indicates whether the class inheritance reflected by a <code>meta::<em>Inheritance</em></code>   was declared as private.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Inheritance T&gt;
struct get_access_specifier;
</code></pre></td><td>returns the <code>meta::<em>Specifier</em></code> reflecting the access specifier   of class inheritance reflected by a <code>meta::<em>Inheritance</em></code>.</td><td>
		<code>meta::<em>Specifier</em></code>
		</td></tr></table></div>

	<h6>?.5.7.1 Operation <code>get_base_name</code><span class="section_name">[refl.ops.base_name]</span></h6>

	<p>For <code>meta::Type</code>s reflecting fundamental types,
	the <code>get_base_name</code> operation returns the longest type specifier name,
	i.e. including <code>long</code>, <code>signed</code> or <code>unsigned</code> modifiers,
	if they describe the identical type.
	</p>

<pre>
[<span class="note">Example:</span>
<code>
meta::get_base_name_v&lt;reflexpr(unsigned)&gt;       // "unsigned int"
meta::get_base_name_v&lt;reflexpr(short)&gt;          // "signed short int"
meta::get_base_name_v&lt;reflexpr(long long)&gt;      // "signed long long int"
meta::get_base_name_v&lt;reflexpr(long double)&gt;    // "long double"
meta::get_base_name_v&lt;reflexpr(signed char)&gt;    // "signed char"
meta::get_base_name_v&lt;reflexpr(unsigned char)&gt;  // "unsigned char"
meta::get_base_name_v&lt;reflexpr(char)&gt;           // "char"
</code>
<span class="note">— end example</span>]
</pre>


	<p>The <code>get_base_name</code> invoked on a <code>meta::Alias</code>
	returns the alias name, not the name of the aliased declaration.
	</p>

<pre>
[<span class="note">Example:</span>
<code>
using foo = int;
using bar = foo;
namespace baz = std;

typedef foo(*pfoo)(double, float);

meta::get_base_name_v&lt;reflexpr(foo)&gt;    // "foo"
meta::get_base_name_v&lt;reflexpr(bar)&gt;    // "bar"
meta::get_base_name_v&lt;reflexpr(baz)&gt;    // "baz"
meta::get_base_name_v&lt;reflexpr(pfoo)&gt;   // "pfoo"
</code>
<span class="note">— end example</span>]
</pre>

	<p>The <code>get_base_name</code> operation returns the type, namespace, etc.
	name without any qualifiers, asterisks, ampersands, angle or square brackets, etc.
	</p>

<pre>
[<span class="note">Example:</span>
<code>
using meta::get_base_name_v;

get_base_name_v&lt;reflexpr(std::vector&lt;int&gt;)&gt;                          // "vector"
get_base_name_v&lt;reflexpr(volatile std::size_t* [10])&gt;                // "unsigned long int"
get_base_name_v&lt;reflexpr(std::set&lt;int&gt;* (*)(std::vector&lt;double&gt;&amp;))&gt;  // ""
get_base_name_v&lt;reflexpr(std::chrono)&gt;                               // "chrono"
get_base_name_v&lt;reflexpr(std::launch)&gt;                               // "launch"
get_base_name_v&lt;reflexpr(static)&gt;                                    // "static"
get_base_name_v&lt;reflexpr(class)&gt;                                     // "class"
</code>
<span class="note">— end example</span>]
</pre>


	<h6>?.5.7.2 Operation <code>get_display_name</code><span class="section_name">[refl.ops.disp_name]</span></h6>

	<p>The <code>meta::get_display_name</code> operation returns an
	implementation-defined string containing the name of the base-level
	entity reflected by a <code>meta::Named</code> which is as close as possible
	to how the name is spelled in the source code. For types in particular
	the display name should be fully qualified and if possible it should preserve
	type or template alias names.
	</p>

<pre>
[<span class="note">Example:</span>
<code>
meta::get_display_name_v&lt;reflexpr(int)&gt;                // "int"
meta::get_display_name_v&lt;reflexpr(const std::string&amp;)&gt; // "const std::string&amp;"
meta::get_display_name_v&lt;reflexpr(std::size_t * [10])&gt; // "std::size * [10]"
meta::get_display_name_v&lt;reflexpr(decltype("foo"))&gt;    // "char const [4]"

</code>
<span class="note">— end example</span>]
</pre>

	<h6>?.5.7.3 Operation <code>get_aliased</code><span class="section_name">[refl.ops.aliased]</span></h6>

	<p>The <code>meta::get_aliased</code> operation invoked on a
	<code>meta::Alias</code> always returns a (non <code>meta::Alias</code>)
	<code>meta::Type</code> or <code>meta::Namespace</code> reflecting the
	entity which has a unique identity at the base-level, which is directly
	or indirectly referenced by the original alias.
	</p>

<pre>
[<span class="note">Example:</span>
<code>

using A = int;
using B = const A;
using C = B*;

template &lt;typename T&gt;
struct S
{
	using X = T&amp;;
};

static_assert( meta::Type&lt;reflexpr(A)&gt;, "");
static_assert( meta::Alias&lt;reflexpr(A)&gt;, "");
static_assert( meta::Type&lt;meta::get_aliased_m&lt;reflexpr(A)&gt;&gt;, "");
static_assert(!meta::Alias&lt;meta::get_aliased_m&lt;reflexpr(A)&gt;&gt;, "");

static_assert( meta::Type&lt;reflexpr(B)&gt;, "");
static_assert( meta::Alias&lt;reflexpr(B)&gt;, "");
static_assert( meta::Type&lt;meta::get_aliased_m&lt;reflexpr(B)&gt;&gt;, "");
static_assert(!meta::Alias&lt;meta::get_aliased_m&lt;reflexpr(B)&gt;&gt;, "");

static_assert( meta::Type&lt;reflexpr(C)&gt;, "");
static_assert( meta::Alias&lt;reflexpr(C)&gt;, "");
static_assert( meta::Type&lt;meta::get_aliased_m&lt;reflexpr(C)&gt;&gt;, "");
static_assert(!meta::Alias&lt;meta::get_aliased_m&lt;reflexpr(C)&gt;&gt;, "");

static_assert(meta::reflects_same_v&lt;
	meta::get_aliased_m&lt;reflexpr(A)&gt;,
	reflexpr(int)
&gt;, "");

static_assert(meta::reflects_same_v&lt;
	meta::get_aliased_m&lt;reflexpr(B)&gt;,
	reflexpr(const int)
&gt;, "");

static_assert(meta::reflects_same_v&lt;
	meta::get_aliased_m&lt;reflexpr(C)&gt;,
	reflexpr(const int *)
&gt;, "");

static_assert(meta::reflects_same_v&lt;
	meta::get_aliased_m&lt;reflexpr(S&lt;A&gt;::X)&gt;,
	reflexpr(int &amp;)
&gt;, "");

static_assert(meta::reflects_same_v&lt;
	meta::get_aliased_m&lt;reflexpr(S&lt;B&gt;::X)&gt;,
	reflexpr(const int &amp;)
&gt;, "");

static_assert(meta::reflects_same_v&lt;
	meta::get_aliased_m&lt;reflexpr(S&lt;C&gt;::X)&gt;,
	reflexpr(const int * &amp;)
&gt;, "");

</code>
<span class="note">— end example</span>]
</pre>

	<p>Template type parameters are also considered to be a special kind of type aliases:
	</p>

<pre>
[<span class="note">Example:</span>
<code>
template &lt;typename A, typename B&gt;
void foo(A a, B b)
{
	using meta::get_base_name_v;
	using meta::get_aliased_m;

	using mA = reflexpr(A);
	using mB = reflexpr(B);

	cout &lt;&lt; "1:" &lt;&lt; get_base_name_v&lt;mA&gt; &lt;&lt; endl;
	cout &lt;&lt; "2:" &lt;&lt; get_base_name_v&lt;get_aliased_m&lt;mA&gt;&gt; &lt;&lt; endl;

	cout &lt;&lt; "3:" &lt;&lt; get_base_name_v&lt;mB&gt; &lt;&lt; endl;
	cout &lt;&lt; "4:" &lt;&lt; get_base_name_v&lt;get_aliased_m&lt;mB&gt;&gt; &lt;&lt; endl;
}

using rank_t = int;
rank_t a = 123;
float b = 45.67;

foo(a, b);

using mR = reflexpr(rank_t);
cout &lt;&lt; "5:" &lt;&lt; get_base_name_v&lt;mR&gt; &lt;&lt; endl;
cout &lt;&lt; "6:" &lt;&lt; get_base_name_v&lt;get_aliased_m&lt;mR&gt;&gt; &lt;&lt; endl;

</code>
produces the following output:
<code>
1:A
2:int
3:B
4:float
5:rank_t;
6:int;
</code>
<span class="note">— end example</span>]
</pre>

	<h6>?.5.7.4 Sequence operations<span class="section_name">[refl.ops.seq]</span></h6>

	<p><em>Metaobject</em>s in a
	<code>meta::ObjectSequence</code> are ordered according
	to the order of each <em>Metaobject</em>'s first declaration in the translation unit.
	</p>

<pre>
[<span class="note">Example:</span>
<code>
struct foo
{
	typedef int t1;
	typedef float t2;

	t1 a, b, c;
	t2 d;
};

using meta_foo = reflexpr(foo);

using meta::get_base_name_v;
using meta::get_element_m;
using meta::get_data_members_m;
using meta::get_member_types_m;

get_base_name_v&lt;get_element_m&lt;get_member_types_m&lt;meta_foo&gt;, 0&gt;&gt; // "t1"
get_base_name_v&lt;get_element_m&lt;get_member_types_m&lt;meta_foo&gt;, 1&gt;&gt; // "t2"

get_base_name_v&lt;get_element_m&lt;get_data_members_m&lt;meta_foo&gt;, 0&gt;&gt; // "a"
get_base_name_v&lt;get_element_m&lt;get_data_members_m&lt;meta_foo&gt;, 1&gt;&gt; // "b"
get_base_name_v&lt;get_element_m&lt;get_data_members_m&lt;meta_foo&gt;, 2&gt;&gt; // "c"
get_base_name_v&lt;get_element_m&lt;get_data_members_m&lt;meta_foo&gt;, 3&gt;&gt; // "d"

</code>
<span class="note">— end example</span>]
</pre>

	<p>The <code>meta::ObjectSequence</code> returned by
	<code>meta::get_data_members</code>, <code>meta::get_public_data_members</code>,
	<code>meta::get_member_types</code> and <code>meta::get_public_member_types</code>
	<em>do not</em> include <em>Metaobject</em>s reflecting inherited class members.
	</p>

<pre>
[<span class="note">Example:</span>
<code>
struct foo
{
	typedef int attr_t;
	attr_t a, b, c, d;
};

struct bar : foo
{
	float e, f;
};

using meta_foo = reflexpr(foo);
using meta_bar = reflexpr(bar);

using meta::get_size_v;
using meta::get_data_members_m;
using meta::get_member_types_m;

get_size_v&lt;get_data_members_m&lt;meta_foo&gt;&gt; // 4
get_size_v&lt;get_data_members_m&lt;meta_bar&gt;&gt; // 2

get_size_v&lt;get_member_types_m&lt;meta_foo&gt;&gt; // 1
get_size_v&lt;get_member_types_m&lt;meta_bar&gt;&gt; // 0
</code>
<span class="note">— end example</span>]
</pre>

	<p>
	The <code>meta::ObjectSequence</code> returned by
	<code>meta::get_data_members</code> and <code>meta::get_member_types</code>
	contain <em>Metaobject</em>s reflecting all class members including those
	which are not publicly accessible otherwise.

	The <code>meta::ObjectSequence</code> returned by
	<code>meta::get_public_data_members</code> and
	<code>meta::get_public_member_types</code>
	contain only the <em>Metaobject</em>s reflecting publicly accessible class members.
	</p>

<pre>
[<span class="note">Example:</span>
<code>
struct foo
{
private:
	typedef int _attr_t;
	_attr_t _a, _b, _c;
public:
	typedef float value_type;
	typedef size_t size_type;
	value_type d;
};

using meta_foo = reflexpr(foo);

using meta::get_size_v;
using meta::get_base_name_v;
using meta::get_element_m;
using meta::get_data_members_m;
using meta::get_public_data_members_m;
using meta::get_member_types_m;
using meta::get_public_member_types_m;

get_size_v&lt;get_data_members_m&lt;meta_foo&gt;&gt; // 4
get_size_v&lt;get_public_data_members_m&lt;meta_foo&gt;&gt;     // 1

get_size_v&lt;get_member_types_m&lt;meta_foo&gt;&gt; // 3
get_size_v&lt;get_public_member_types_m&lt;meta_foo&gt;&gt;     // 2

get_base_name_v&lt;get_element_m&lt;get_data_members_m&lt;meta_foo&gt;, 0&gt;&gt; // "_a"
get_base_name_v&lt;get_element_m&lt;get_public_data_members_m&lt;meta_foo&gt;, 0&gt;&gt;     // "d"
</code>
<span class="note">— end example</span>]
</pre>

	The <code>unpack_sequence</code> operation is applied to models of
	<code>meta::ObjectSequence</code>. It is <em>equivalent</em> to:

<pre><code>
namespace std {
namespace experimental {
namespace meta {

template &lt;ObjectSequence Seq, template &lt;typename ...&gt; class Tpl&gt;
struct unpack_sequence
{
	typedef Tpl&lt;
		get_element_m&lt;Seq, 0&gt;,
		get_element_m&lt;Seq, 1&gt;,
		<em>...,</em>
		get_element_m&lt;Seq, get_size_v&lt;Seq&gt;-1&gt;,
	&gt; type;
};

template &lt;ObjectSequence Seq, template &lt;typename ...&gt; class Tpl&gt;
using unpack_sequence_t = typename unpack_sequence&lt;Seq, Tpl&gt;::type;

} // namespace meta
} // namespace experimental
} // namespace std
</code></pre>

<pre>
[<span class="note">Example:</span>
<code>
struct foo
{
	int a;
	bool b;
	char c;
	double d;
};

template &lt;meta::DataMember ... MDM&gt;
using helper = tuple&lt;meta::get_reflected_type_t&lt;MDM&gt;...&gt;;

using X = meta::unpack_sequence_t&lt;
	meta::get_data_members_m&lt;reflexpr(foo)&gt;,
	helper
&gt;;

is_same_v&lt;X, tuple&lt;int, bool, char, double&gt;&gt; // true
</code>
<span class="note">— end example</span>]
</pre>


	<h6>?.5.7.5 Specifier operations<span class="section_name">[refl.ops.spec]</span></h6>

	<p>[<span class="note">Note:</span> There is a dual interface for retrieving specifier-related metadata.
	One is using the <code>meta::Specifier</code> concept and its operations which is
	more generic, and another using the boolean operations like <code>meta::is_static</code>,
	<code>meta::is_public</code>, etc. which may be more convenient in simpler use-cases.
	<span class="note">— end note</span>]</p>

<pre>
[<span class="note">Example:</span>
<code>
struct S
{
private:
	int i;
public:
	float f;
};

using meta_S = reflexpr(S);
using meta_S_i = meta::get_element_m&lt;meta::get_data_members_m&lt;meta_S&gt;, 0&gt;;
using meta_S_f = meta::get_element_m&lt;meta::get_data_members_m&lt;meta_S&gt;, 1&gt;;

using meta::reflects_same_v;
using meta::get_access_specifier_m;

reflects_same_v&lt;reflexpr(private),get_access_specifier_m&lt;meta_S_i&gt;&gt;  // true
reflects_same_v&lt;reflexpr(public), get_access_specifier_m&lt;meta_S_i&gt;&gt;  // false
reflects_same_v&lt;reflexpr(public), get_access_specifier_m&lt;meta_S_f&gt;&gt;  // true

meta::is_private_v&lt;meta_S_i&gt; // true
meta::is_public_v&lt;meta_S_i&gt;  // false
meta::is_public_v&lt;meta_S_f&gt;  // true
</code>
<span class="note">— end example</span>]
</pre>

	<h4>?.6 The reflection operator<span class="section_name">[refl.reflexpr]</span></h4>

	<p>The result of the invocation of the <code>reflexpr</code> is a type satisfying
	<code>meta::Object</code> and other <code>meta</code> concepts, depending
	on the operand.
	The returned type is implementation-defined.
	Meta-operations on it describe the operand.
	</p>
    <p>
      The <code>reflexpr</code> operator takes an <em>id-expression</em> (5.1), or
      <em>access-specifier</em> (10) as operand, or nothing.
      The <em>id-expression</em> must be uniquely resolved through regular lookup,
			as if used outside of the <code>reflexpr</code> operator.
      Otherwise, the expression is ill-formed.
	</p>
      <ul>
				<li>If no operand is passed to <code>reflexpr</code> or if the operand
				is "<code>::</code>", then the result will be satisfying
				<code>meta::GlobalScope</code>.</li>
        <li>Otherwise, if the operand is a <em>union-name</em>, the result will
				be satisfying <code>meta::Record</code>.</li>
        <li>Otherwise, if the operand is a <em>class-name</em>, the result will
				be satisfying <code>meta::Class</code>.</li>
        <li>Otherwise, if the operand is a <em>enum-name</em>, the result will
				be satisfying <code>meta::Enum</code>.</li>
        <li>Otherwise, if the operand is a <em>type-name</em>, the result will
				be satisfying <code>meta::Type</code>.</li>
        <li>Otherwise, if the operand is a <em>typedef-name</em>, the result will be satisfying
				<code>meta::Type</code> and <code>meta::Alias</code>.</li>
        <li>Otherwise, if the operand is a <em>namespace-name</em>, the result
				will be satisfying <code>meta::Namespace</code>.</li>
        <li>Otherwise, if the operand is the name of a
				<em>namespace-alias-declaration</em>, the result will be satisfying
				<code>meta::Namespace</code> and <code>meta::Alias</code>.</li>
        <li>Otherwise, if the operand is a <em>class-data-member-name</em>,
				the result will be satisfying <code>meta::Variable</code>.</li>
        <li>Otherwise, if the operand is a <em>variable-name</em>,
				the result will be satisfying <code>meta::Variable</code>.</li>
        <li>Otherwise, if the operand is a <em>enumerator-name</em>,
				the result will be satisfying <code>meta::Constant</code>.</li>
				<li>Otherwise, if the operand is any of <code>static</code>,
				<code>virtual</code>, <code>enum</code>, <code>class</code>,
				<code>struct</code>, <code>union</code>,
				<code>public</code>, <code>protected</code>, <code>private</code>,
				the result will be satisfying <code>meta::Specifier</code>.</li>

      </ul>
    <p>
      If the scope of the declaration of the <em>id-expression</em> is a class,
			a struct or a union then the result of <code>reflexpr</code> is also
			satisfying <code>meta::RecordMember</code>.
    </p>
    <p>
      If the scope of the declaration of the <em>id-expression</em> is an enum
			then the result of <code>reflexpr</code> is also satisfying
			<code>meta::EnumMember</code>.
    </p>
    <p>
      The invocation of <code>reflexpr</code> on all other kinds of <em>id-expressions</em>
      is ill-formed. The proposal will be extended in the future revisions
			to allow additional operands.
		</p>
<pre>
[<span class="note">Example:</span>
<code>
reflexpr() // reflects the global namespace
reflexpr(::) // reflects the global namespace
reflexpr(std) // reflects the namespace
reflexpr(int) // reflects the fundamental type
reflexpr(std::size_t) // reflects the type alias
reflexpr(std::launch) // reflects the enum type
reflexpr(std::vector&lt;int&gt;) // reflects the class
reflexpr(std::pair&lt;int, int&gt;::first_type) // reflects the member typedef 
reflexpr(std::pair&lt;int, int&gt;::first) // reflects the data member
reflexpr(std::launch::async) // reflects the enumerator

reflexpr(1) // <em>ill-formed</em>
reflexpr(std::sin) // <em>ill-formed</em>
reflexpr(std::vector) // <em>ill-formed</em>
reflexpr(is_same_v&lt;void,void&gt;) // <em>ill-formed</em>
</code>
<span class="note">— end example</span>]
</pre>

	<p>[<span class="note">Note:</span>The expressions <code>reflexpr()</code>
	and <code>reflexpr(::)</code> both reflect the global scope.
	It is possible that in the future only one of them will be chosen for this
	purpose.
	<span class="note">— end note</span>]
	</p>

	<h5>?.6.1 Redeclarations<span class="section_name">[refl.reflexpr.redecl]</span></h5>

	<p>The meta data queried by <code>reflexpr</code> depends on the point of invocation
	of the operator; only declarations appearing in the translation unit before the invocation of the
	<code>reflexpr</code> operator will be visible.
	Subsequent invocations are independent of prior invocations, as if all compiler
	generated types were unique to each <code>reflexpr</code> invocation.
	</p>

<pre>
[<span class="note">Example:</span>
<code>
using meta::get_size_v;
using meta::get_data_members_m;

struct foo;
using meta_foo_fwd1 = reflexpr(foo);
constexpr size_t n1 = get_size_v&lt;get_data_members_m&lt;meta_foo_fwd1&gt;&gt;; // 0

struct foo;
using meta_foo_fwd2 = reflexpr(foo);
constexpr size_t n2 = get_size_v&lt;get_data_members_m&lt;meta_foo_fwd2&gt;&gt;; // 0

using meta::reflects_same_v;

constexpr bool b1 = is_same_v&lt;meta_foo_fwd1, meta_foo_fwd2&gt;;       // <em>unspecified</em>
constexpr bool b2 = reflects_same_v&lt;meta_foo_fwd1, meta_foo_fwd2&gt;; // true

struct foo { int a,b,c,d; };
using meta_foo = reflexpr(foo);
constexpr size_t n3 = get_size_v&lt;get_data_members_m&lt;meta_foo&gt;&gt;;      // 4

constexpr bool b3 = is_same_v&lt;meta_foo_fwd1, meta_foo&gt;;       // false
constexpr bool b4 = reflects_same_v&lt;meta_foo_fwd1, meta_foo&gt;; // true
</code>
<span class="note">— end example</span>]
</pre>

	<p>[<span class="note">Note:</span> In order to distinguish the reflections
	of incomplete forward declarations of types a new concept like
	<code>meta::IncompleteType</code> or <code>meta::ForwardDeclarated</code>
	or a new operation like <code>meta::is_forward_declared</code> will be
	added in a future revision.
	<span class="note">— end note</span>]
	</p>

</blockquote>

<div id="revisions">
<h2>Revision history</h2>

<h4>Revision 1 (<a href="#ref-N3996">N3996</a>)</h4>

<p>Describes the method of static reflection
by the means of compiler-generated anonymous types. Introduces the first version
of the metaobject concepts and some possiblities of their implementation.
Also includes discussion about the motivation and the design rationale for the proposal.
</p>

<h4>Revision 2 (<a href="#ref-N4111">N4111</a>)</h4>

<p>Refines the metaobject concepts and introduces
a concrete implementation of their interface by the means of templates similar
to the standard type traits. Describes some additions to the standard library
(mostly meta-programming utilities), which simplify the use of the metaobjects.
Answers some questions from the discussion about N3996 and expands the design
rationale.
</p>

<h4>Revision 3 (<a href="#ref-N4451">N4451</a>)</h4>

<p>Incorporates the feedback from the discussion
about N4111 at the Urbana meeting, most notably reduces the set of metaobject concepts and refines their
definitions, removes some of the additions to the standard library added in the previous revisions.
Adds context-dependent reflection.
</p>

<h4>Revision 4 (<a href="#ref-P0194R0">P0194R0</a>)</h4>

<p>Further refines the concepts from N4111; prefixes
the names of the metaobject operations with <code>get_</code>, adds new operations,
replaces the metaobject category tags with new metaobject traits.
Introduces a nested namespace <code>std::meta</code> which contains most
of the reflection-related additions to the standard library.
Rephrases definition of meta objects using Concepts Lite. Specifies the
reflection operator name — <code>reflexpr</code>.
Introduces an experimental implementation of the reflection operator in clang.
Drops the context-dependent reflection from N4111 (will be re-introduced later).
</p>

<h4>Revision 5 (<a href="#ref-P0194R1">P0194R1</a>)</h4>

<p>Dropped all metaobject traits except <code>is_metaobject</code>. All metaobject
classification is now done by using the concepts. We assume that the following
syntax of the Concepts specification is implemented:
</p>

<pre><code>
template &lt;T&gt;
constexpr bool Concept = <em>unspecified</em>;
</code></pre>

<p>and also assuming that the Concepts TS Issue 29 is resolved and that
<code>Concept&lt;T&gt;</code> is a generally usable boolean expression,
so that the following is valid code:</p>

<pre><code>
static_assert(Concept&lt;T&gt;, " ... ");

using U = std::conditional_t&lt;Concept&lt;T&gt;, T1, T2&gt;;

if(Concept&lt;T&gt;) { /* ... */  }
</code></pre>

<p>The <code>meta::Scoped</code> concept has been renamed to <code>meta::ScopeMember</code>.
The <code>meta::Constant</code> and <code>meta::Specifier</code> concepts,
and several new operations have been added.
</p>

<p>The aliases for the operation templates returning metaobjects had previously
the <code>_t</code> suffix; this has been changed to the <code>_m</code> suffix. For example:
</p>
<pre>
<code>
get_type_t -&gt; get_type_m
get_scope_t -&gt; get_scope_m
get_aliased_t -&gt; get_aliased_m
get_data_members_t -&gt; get_data_members_m
</code>
</pre>

<h4>Revision 6 (P0194R2)</h4>

<p>The following concepts from P0194R1 were dropped in order to simplify
the proposal:
<code>meta::Linkable</code>, <code>meta::Enumerator</code>,
<code>meta::DataMember</code>, <code>meta::MemberType</code>,
<code>meta::EnumClass</code>, <code>meta::TypeAlias</code> and
<code>meta::NamespaceAlias</code>.
</p>

<p>The following concepts were added to the proposal:
<code>meta::TagType</code>, <code>meta::Record</code>,
<code>meta::EnumMember</code>.
</p>


<p>Unlike in the previous proposal, metaobjects reflecting anonymous entities -
the global scope, anonymous namespaces and classes, etc. <em>do</em> conform to the
<code>meta::Named</code> concept and implement the name-returning operations.
</p>

<p>Unlike in the previous proposal, metaobjects reflecting the global scope
<em>do</em> conform to the <code>meta::ScopeMember</code> concept and the
<code>meta::get_scope</code> operation. For arguments reflecting
the global scope returns a metaobject reflecting the global scope
(i.e. the global scope is its own scope).
</p>

<p>Metaobjects reflecting built-in types and types like pointers, references,
arrays, etc. now don't have a scope (i.e. they do not conform to the
<code>meta::ScopeMember</code> concept).
</p>

<p>We have added a different mechanism for distinguishing between
non-scoped and scoped <code>enum</code>s - the <code>meta::is_scoped_enum</code>
operation. Unlike in the previous proposal <code>meta::Enum</code> reflecting
a non-scoped enum <em>is</em> a <code>meta::Scope</code>.
</p>

<p>We now allow the default construction and copy construction of
values of metaobject types.
</p>

<p>Direct reflection of class data members, member types and type aliases,
enumerators and global scope/namespace-level variables has been added.
For example:
</p>
<pre>
<code>
enum class E { a, b, c, d};

using ME_a = reflexpr(E::a); // valid

struct S { using T = int; T a; };

using MS_T = reflexpr(S::T); // valid
using MS_a = reflexpr(S::a); // valid
</code>
</pre>

<p>The typedef (type-alias) reflection has been simplified based on the
feedback from Oulu. Previously we required reflection to be aware about all
aliases in a <em>"chain"</em> even in the context of templates. For example:
</p>
<pre>
<code>
using A = int;
using B = A;
using C = B;

template &lt;typename T&gt;
struct S
{
	using X = T;
};

using Mint = reflexpr(int);
using MA = reflexpr(A);
using MB = reflexpr(B);
using MC = reflexpr(C);

using MSintX = reflexpr(S&lt;int&gt;::X);
using MSAX = reflexpr(S&lt;A&gt;::X);
using MSBX = reflexpr(S&lt;B&gt;::X);
using MSCX = reflexpr(S&lt;C&gt;::X);
</code>
</pre>

<p>In the previous proposals we required the following (i.e. that reflection
should be aware of the whole <em>"chain"</em> of aliases -
<code>S&lt;C&gt;::X -&gt; C -&gt; B -&gt; A -&gt; int</code>):
</p>
<pre>
<code>
static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MSCX&gt;, MC&gt;, "");
static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MSBX&gt;, MB&gt;, "");
static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MSAX&gt;, MA&gt;, "");

static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;meta::get_aliased_m&lt;MSCX&gt;&gt;, MB&gt;, "");
static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;meta::get_aliased_m&lt;meta::get_aliased_m&lt;MSCX&gt;&gt;&gt;, MA&gt;, "");

static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MC&gt;, MB&gt;, "");
static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MB&gt;, MA&gt;, "");
static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MA&gt;, Mint&gt;, "");
</code>
</pre>

<p>Now we require only that the type alias knows the <em>"canonical"</em> type
which it refers to - the type which has a unique identity at the base level (i.e.
<code>S&lt;C&gt;::X -&gt; int</code>, <code>C -&gt; int</code>, <code>B -&gt; int</code>,
<code>A -&gt; int</code>):
</p>
<pre>
<code>
static_assert(meta::Alias&lt;MSCX&gt;, "");
static_assert(meta::Alias&lt;MSBX&gt;, "");
static_assert(meta::Alias&lt;MSAX&gt;, "");

static_assert(meta::Alias&lt;MC&gt;, "");
static_assert(meta::Alias&lt;MB&gt;, "");
static_assert(meta::Alias&lt;MA&gt;, "");

static_assert(!meta::Alias&lt;Mint&gt;, "");

static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MSCX&gt;, Mint&gt;, "");
static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MSBX&gt;, Mint&gt;, "");
static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MSAX&gt;, Mint&gt;, "");

static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MC&gt;, Mint&gt;, "");
static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MB&gt;, Mint&gt;, "");
static_assert(meta::reflects_same_v&lt;meta::get_aliased_m&lt;MA&gt;, Mint&gt;, "");

</code>
</pre>

<p>The mechanism for enumerating public-only vs. all (including non-public ones)
class members has been changed. Now the <em>"basic"</em> operations like
<code>meta::get_data_members</code>, <code>meta::get_member_types</code>, etc.
return all members, and the <code>meta::get_public_data_members</code>,
<code>meta::get_public_member_types</code>, return only the public class members.
</p>

</div>
<div id="acks">
<h2>Acknowledgments</h2>

<p>Thanks to Ricardo Fabiano de Andrade, Roland Bock and Klaim - Joël Lamotte
who provided valuable feedback, criticism and suggestions.
</p>
</div>
<div id="ref-P0194R0">
<h2>References</h2>

<table class="references">
<tr id="ref-P0194R1">
	<th>[P0194R1]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r1.html">
		Chochlík M., Naumann A. — P0194R1 - Static reflection (revision 5)
	</a>
	</td>
</tr>

<tr id="ref-P0194R0">
	<th>[P0194R0]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r0.pdf">
		Chochlík M., Naumann A. — P0194R0 - Static reflection (revision 4)
	</a>
	</td>
</tr>

<tr id="ref-N4451">
	<th>[N4451]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4451.pdf">
		Chochlík M. — N4451 - Static reflection (revision 3)
	</a>
	</td>
</tr>

<tr id="ref-N4111">
	<th>[N4111]</th>
	<td>
	<a href="https://isocpp.org/files/papers/n4111.pdf">
		Chochlík M. — N4111 - Static reflection (revision 2)
	</a>
	</td>
</tr>

<tr id="ref-N3996">
	<th>[N3996]</th>
	<td>
	<a href="https://isocpp.org/files/papers/n3996.pdf">
		Chochlík M. — N3996 - Static reflection
	</a>
	</td>
</tr>

<tr id="ref-P0385R0">
	<th>[P0385R0]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0385r0.pdf">
		Chochlík M., Naumann A. — P0385R0 - Static reflection - Rationale, design and evolution
	</a>
	</td>
</tr>

<tr id="ref-P0385R1">
	<th>[P0385R1]</th>
	<td>
		Chochlík M., Naumann A. — P0385R1 - Static reflection - Rationale, design and evolution
	</td>
</tr>

</table>
</div>

</body>
</html>
