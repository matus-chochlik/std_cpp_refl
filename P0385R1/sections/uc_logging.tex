\subsection{Logging}

When tracing and logging the execution of functions\footnote{especially template
functions} it is sometimes desirable to also include the names of the parameter
types or even the names of the parameters and other variables.

The best we can do with just the \verb@std::type_info@ is the following:

\begin{minted}[tabsize=4]{cpp}
#if __PLATFORM_ABC__
std::string demangled_type_name(const char*) { /* implementation 1 */ }
#else if __PLATFORM_MNO__
std::string demangled_type_name(const char*) { /* implementation 2 */ }
#else if __PLATFORM_XYZ__
std::string demangled_type_name(const char*) { /* implementation N */ }
#else
std::string demangled_type_name(const char* mangled_name)
{
	// don't know how to demangle this; let's try our luck
	return mangled_name;
}
#endif

template <typename T>
T min(const T& a, const T& b)
{
	log()   << "min<"
	        << demangled_type_name(typeid(T).name())
	        << ">(" << a << ", " << b << ") = ";

	T result = a<b?a:b;

	log()   << result << std::endl;

	return result;
}

\end{minted}

Which may or may not work, depending on the platform.

With the help of reflection we can do:

\begin{minted}[tabsize=4]{cpp}
template <typename T>
T min(const T& a, const T& b)
{
	log()   << "min<"
	        << get_base_name_v<reflexpr(T)>
	        << ">(" << a << ", " << b << ") = ";

	T result = a<b?a:b;

	log()   << result << std::endl;

	return result;
}
\end{minted}

The \verb@__PRETTY_FUNCTION__@ macro generated by the compiler could be also
used in this case, but the format of the string which this macro expands into
is not customizable (which may be necessary for logs formatted in XML, JSON, etc.

A more elaborate output containing also the parameter names, type names and values
can be achieved by using reflection:

\begin{minted}[tabsize=4]{cpp}
template <typename T>
T min(const T& a, const T& b)
{
	log()   << "function: min<"
	        << get_base_name_v<get_aliased_m<reflexpr(T)>>
	        << ">("
	        << get_base_name_v<reflexpr(a)> << ": "
	        << get_base_name_v<get_aliased_m<get_type_m<reflexpr(a)>>>
	        << " = " << a
	        << get_base_name_v<reflexpr(b)> << ": "
	        << get_base_name_v<get_aliased_m<get_type_m<reflexpr(b)>>>
	        << " = " << b
	        << ")" << std::endl

	T result = a<b?a:b;

	log()   << get_base_name_v<reflexpr(result)> << ": "
	        << get_base_name_v<get_aliased_m<get_type_m<reflexpr(result)>>>
	        << " = " << result << std::endl;

	return result;
}
\end{minted}

Calling

\begin{minted}[tabsize=4]{cpp}
double x = 12.34;
double y = 23.45;
double z = min(x, y);
\end{minted}

would produce the following log entries:

\begin{verbatim}
function: min<double>(a: double = 12.34, b: double = 23.45)
result: double = 12.34
\end{verbatim}


It is true that the lines:
\begin{minted}[tabsize=4]{cpp}
	<< get_base_name_v<reflexpr(a)> << " = "
	<< get_base_name_v<reflexpr(b)> << " = "
\end{minted}

could be replaced by preprocessor stringization

\begin{minted}[tabsize=4]{cpp}
	<< BOOST_PP_STRINGIZE(a) << ": "
	<< BOOST_PP_STRINGIZE(b) << ": "
\end{minted}

or just hard coded strings, like

\begin{minted}[tabsize=4]{cpp}
	<< "a: "
	<< "b: "
\end{minted}

but the compiler would not force the programmer to change the macro parameter
or the content of the string the if the parameters \verb@a@ and \verb@b@ were renamed
for example to \verb@first@ and \verb@second@. On the other hand, it {\em would}
enforce the change if reflection was used.

Furthermore, with the \meta{Function} concept and the
\hyperref[context-dependent-reflection]{context-dependent reflection} features,
even more would be possible; The function name and even the parameter names can
be obtained from reflection and encapsulated into a function.

\begin{minted}[tabsize=4]{cpp}
template <typename MetaFunction, typename ... P>
void log_function_exec(MetaFunction, const std::tuple<P&...>& params)
{
	log()   << "function: "
	        << get_base_name_v<MetaFunction>
	        << std::endl;

	// obtain the MetaParameter(s) from the MetaFunction
	// and print them pairwise with the values from params.
	for_each<get_parameters<MetaFunction>>(
		[&params](auto meta_param)
		{
			using MP = decltype(meta_param)::type;
			log()  << get_base_name_v<MP> << ": "
			       << std::get<get_position_v<MP>>(params)
			       << std::endl;
		}
	);
}

template <typename T>
T min(T a, T b)
{
	log_function_exec(reflexpr(this::function), std::tie(a, b));
	/* ... */
}

template <typename T>
T max(T a, T b)
{
	log_function_exec(reflexpr(this::function), std::tie(a, b));
	/* ... */
}

template <typename T>
T avg(T a, T b)
{
	log_function_exec(reflexpr(this::function), std::tie(a, b));
	/* ... */
}
\end{minted}

Logging is one of the use cases where typedef reflection is really useful.
Consider for example that we want to log the execution of a function with
the following signature:

\begin{minted}[tabsize=4]{cpp}
std::string::iterator foo(std::string::iterator iter);
\end{minted}

The log is much cleaner and informative if it contains the typedef name
\verb@iterator@ instead of \verb@const char*@ on one platform,
\verb@__normal_iterator<pointer, std::basic_string<char>>@ on another and
something completely different on yet another. On some platforms the definition
of \verb@iterator@ may even vary between build modes\footnote{32-bit vs. 64-bit or 
debug vs. release} which may lead to confusion.
